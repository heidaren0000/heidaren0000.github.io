---
layout: post
title: JavaScript 面向对象
date: 2020-02-15 09:20:00 +0800
authorize: Daren
categories: JavaScript
nutshell: 简单了解 JavaScript 中的 OOP
---



注意 JS 中首字母大写的函数一般都是系统函数, 或者自己定义的构造函数.

## 介绍面向对象

### 四个核心概念

- 封装 Encapsulation 
- 抽象 Abstraction
- 继承 Inheritance
- 多态 Polymorphism

像 C 这样的面向过程语言, 基本的组成元素是函数(function), 各个函数之间相互调用, 显得乱七八糟, 有人戏称为“意大利面代码(spaghetti code)”, 使用面向过程就可以有效避免混乱的情况发生

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-1-procedural-programming.png)

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-2-spaghetti.png)

 面向对象就相当于把变量(variety)和函数(function)进行了分门别类的打包整理进了各种的类里, 变成属性(props) 和 方法(methods). 

#### 封装 : 减少复杂性, 增加复用性

类的不同实例彼此分离不影响, 好比现实中不同事物属性(property)和行为方法(method)也是彼此分离的. 这就是封装(Encapsulation)

下面的例子展示了同样的功能分别使用面向过程(POP)和面向对象(OOP)实现

```javascript
let baseSalary = 30_000;
let overtime = 10;
let rate = 20;

function gatWage(baseSalary, overtime, rate) {
    return baseSalary + (overTime * rate);
}

```

```javascript
let employee = {
    baseSalary: 30_000,
    overtime: 10,
    rate: 20,
    gatWage: function(){
        return this.baseSalary + (this.overtime * this.rate);
    }

};
employee.gatWage(); 
```

可以看到 OOP 的写法省掉了参数

#### 抽象 : 减少复杂性, 减少冲突

抽象的特性使得我们操作面向对象的操作跟操作一个 CD 机一样---根本不用在意内部在发生什么, 像一个黑箱一样, 内部的复杂机制都隐藏起来, 留一个接口, 他就能运行.

由于可以在不改变接口的情况下改变类内部的机制, 这个特性非常有用.

#### 继承 : eliminate redundant code 减少冗余代码

像真的“继承”一样, 面向对象里的继承可以让你让一个子类继承父类的方法和属性, 之后还能修修补补, 添加新的特性, 提高代码的复用性.

#### 多态 Polymorphism : refactor ugly switch/case statemets 重构条件语句

Polymorphism 这个词很多老外看了都是一脸懵逼. 但是也不是很难理解. 'poly' 指的是 'many', 'morphism' 指的是 'forms', 直译过来就是 “形式很多”, “多态”. 面向对象的这个特性能让你省掉很多的 if-else 和 switch 语句, 因为这个特性可以只让符合条件的元素进行加载.

## 对象 Object

### 创建对象 Creating Objects

下面的写法叫 object literal syntax (对象文本参数)

```javascript
const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    draw: function(){
        console.log('draw');
    }
};

circle.draw();
```

如果运行的话, 会在 console 中看到 'draw'.

这就简单的定义了一个对象.

如果你觉得上面的 `cricle` 对象不错, 要重新建立一个 circle 对象, 那么除了复制粘贴(要是复制的好几十个之后才发现错误, 那你只能一个一个进行修改了), 还可以用工厂函数(Factories)或者构造函数.

### 工厂函数和构造函数 Factories and Constructors

#### 工厂函数 Factories Function

简单的来理解, 这个工厂函数的作用就是像一个工厂一样.每次执行的时候都会“造”一个对象出来.

```javascript
function createCricle(radius){
    return {
        radius,
        draw: function(){
            console.log('draw');
        }
    };
}

const circle = createCricle(1);
circle.draw();
```

现在就可以随心所欲的创建对象了.

本质上, 工厂函数使用的是 object liberty syntax 对象字符参数来创建对象直接返回了一个对象, 没有动 js 原生的构造函数.

### 构造函数 Constructors

构造函数的首字母需要大写, 同时需要使用 new 运算符

```javascript
// Constructor Function
function Circle(raduis) {
    this.radius = raduis;
    this.draw = function() {
        console.log('draw');
    }

}
const another = new Circle(1);
```



**需要注意的是 Javascript 中没有 class 的概念的, 但是貌似 Node 中有**

new运算符会执行下面的操作:

- 创建一个空的对象 {}
- 将构造函数内的 this 指向刚刚创建的空对象里. 
- 从构造函数里面返回对象(如果你没有给构造函数写明切的 return, 默认返回的就是 return this「也就是对象」, Java 或者 C++ 的构造函数跟这里不一样的是他们构造函数没有返回值) 

由于 new 的缘故, 构造函数里的 this 值都指向新的空对象了, 默认情况下 this 指向的是浏览器里的 window 对象(也就是说你要是不加 new 的话, 直接操作的就是 window 对象, 里面的对象在哪都能访问)或者 NodeJS 的 GLOBAL.

本质上, 构造函数就是对对象默认的 constructor properties 进行覆盖 override

不论是工厂函数还是构造函数, 都是标准的 JavaScript 函数, 而且效果都是相通的. 有不同语言习惯的人用的就是自己习惯的写法来写构造函数.

对于会 C++ 和 Java 的同学来说, 构造函数用起来比较习惯

### 构造函数属性 Constructor Property

每一个 JS 对象都有一个 构造器属性 Constructor Property 用来构造或者创建对象, 如果你在浏览器的 console 中运行 `对象.constructor` 这样的话就会在控制台显示这个对象的构造器属性. 要注意这个只有构造函数才会有, 工厂函数创建的构造函数属性还是默认的构造函数属性, 即空属性.

```javascript
// 构造函数创建的对象, 其中有自定义构造函数属性
another.constructor
ƒ Circle(raduis) {
    this.radius = raduis;
    this.draw = function() {
        console.log('draw');
    }

}
// 工厂函数创造的对象, 其中没有自定义的构造函数属性, 是默认的构造函数属性
circle.constructor
ƒ Object() { [native code] }
```

- 每一个对象都具有构造函数属性, 默认的构造器属性是空方法, 如果是继承的构造函数, 看这个https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor
- 构造函数属性是隐藏的, 需要单独访问`对象.constructor` 才能查看呢
- 如果你用了自己写的构造方法, 那么默认的构造器属性就会被你的方法覆盖.
- 由于 JavaScript 的面向对象属性, 实际上类型的变量创建也会调用 JavaScript 引擎相应的构造器, 举个例子: 

```javascript
let x = {};
// js 引擎实际上会把这个翻译成: 
// let x = new Object(); 
'', "", ``
// 这三个会被使用 new String();
true, false
// 这两个会使用 new Boolean();
1, 2, 3...
// 这个会使用 new Number();
.... 
```

###函数其实是对象 Functions are Objects

很多人都对此感到疑惑, 但是事实如此, JS 中的函数和对象一样具有各种属性, 比如可以直接在 console 中访问函数对象的属性, 甚至还有构造函数.

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-1-FunctionObjecr.png)

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-2-FunctionObjectorConstructor.png)

实际上, 函数对象调用的就是函数的构造方法 `Function()`, 其中第一个函数是参数, 第二个参数就是函数的语句, 函数语句在构造函数中被解析

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-3-FunctionObjectConstructorSyntx.png)

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-4-afterFunctionConstruction.png)

#### 构造函数的缺省方法

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-5-what-available-in-construction.png)

图片里面的紫色小框开头的就是构造函数的缺省方法, 而蓝色的值的是构造函数对象内的属性.

举个例子:

```javascript
Circle.call({}, 1);
```

call 方法会把 this 定向到第一个参数的对象里, 然后后面的参数就是要传入的参数, 如果你有多个参数的话, 直接在后面接上就行. 这个产生的结果跟使用 new 运算符相同.

```javascript
Circle.apply({}, [1,2,3,4]);
```

apply 方法的效果和前面的 call 一样, 不同之处在于它的第二个参数是数组, 如果有多个参数的话直接吧参数导入到数组就可以. 不同于 call 方法的每个待传入构造函数的的参数分别占据一个参数的位置. 这个方法在你已经有一个现成数组的时候特别好用.	 

### 原始类型和引用类型 Primitives and Reference Types

js 中分成下面两种类型: Value Types (值类型) Reference Types(引用类型), 理解这些类型特别重要, 

Value Types:

- Number
- String
- Boolean
- Symbol
- undefined
- null

Reference Types

- Object
- Function
- Array

Primitives are copied by their value

Objects are copied by their reference

虽然函数本身是引用类型, 但是传递参数的时候会根据参数自己本身的类型来决定是直接传递(传递引用)还是间接传递(传递值).

如果是像 Number 这种值类型的数据, 就会把参数复制一份, 给函数自己的本地变量, 这样内外都互不影响.

如果传递的是 Object 这种引用类型的数据, 相应的操作就是传递参数的引用, 这样在函数内部对传入的参数进行了修改, 函数外也会受到影响.

### 属性 Working with Properties

#### 添加/删除属性 Adding/Removing Properties

##### 添加属性

如果你从客户端取回一堆 JSON 之后想要继续添加一些属性,   比如 tocken 这种, 就需要添加属性了. 

添加属性的方式很简单, 直接赋值就可以, JS 会自动帮你把这个添加到对象里. 

添加有两种表示方法: 括号表示法(bracket notation)和点表示法(dot notation), 这两种方法在访问

##### 点表示法(dot notation)

- 用`.`来访问属性
- 属性名称中不能出现特殊符号和空格
- 不能将变量作属性名

##### 括号表示法(bracket notation)

- 用`[ ]`来访问属性
- 允许属性名称中使用特殊符号和空格
- 可以在里面使用变量来给属性进行动态命名.

##### 删除属性

要删除属性, 只要在访问属性的语句前面加一个 `delete` 即可.

```javascript
delete object.attibute;
```

###遍历属性 (Enumerating Properties)

有时候你需要遍历或者枚举一个对象, 这时只要使用`for`循环, 在下面的例子里面, 每次循环都会把属性的名字给 key, 也就是说, 如果要进一步查看某个对象的话, 直接用括号法访问 circle 对象中的 key 属性即可.

```javascript
for (let key in circle) {
  console.log(key, circle[key]);
}
```

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-1-firsttime-for.png)

如果不想让方法出现在列表中, 可以用下面的小妙招

```javascript
for(let key in circle) {
    if(typeof circle[key] !== 'function')
    	console.log(key, circle[key]);
}
```

还有一种自带的方法, 可以将一个对象中所有的属性名称存到一个数组中返回:

```javascript
const keys = Object.keys(circle);
console.log(keys);
```

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-2-get-the-array.png)

出了遍历元素, 还可以确认对象中是否存在某个属性, 这个功能非常有用:

```javascript
if('radius' in circle)
  	console.log('circle has a radius');
```

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-3-circle-has-a-radius.png)

简而言之: 要遍历对象, 使用 for 循环; 要获取所有的属性名称, 使用 `Object.keys()` 方法; 要确定是否存在某个元素, s使用`if('what' in object)` 语句.

## 抽象 (abstraction)

值暴露需要的, 隐藏内部的. Hide the details, Show the essentials

### 私有属性 Private Properties

如果你要设置私有的属性来防止被外部访问, 直接在构造函数里面用 `let`进行声明就好了.

```javascript
function Circle(radius){
  let color = 'red'; // 这里的作用域是构造函数本身.
  this.raduis = radus; // 这里的作用域是 new 生成的新对象.
  ...
}
```



前面我们提到 构造函数中的 `this` 指向的是`new`产生的空对象, 那么如果我们在声明新的变量的时候把`this`去掉, 就意味着新的变量作用域是构造函数本身, 而不是新建的对象, 在构造函数执行完毕之后, 这些在构造函数内部的对象就被销毁了, 不会保留到最后, 自然不能从外部被访问.

另外, 在作用域上还需要更加细分, 详情请见之后的文章:  “closure 和 scope -- JS 作用域 48min”

### Getters / Setters

当对象中已经有私有的属性时, 如何在对象外部获取和设定私有属性呢? Gitters 可以用来在外部读取只读属性, Setter 可以在外部修改属性.

当然, 如果要获取某个私有变量的值, 可以直接写一个函数返回就可以了, 就像 java 里面的取值函数一样. 但是这么做不能对值进行修改, 而且用写函数的方法来写变量真的是挺别扭的...

```javascript
...
this.getDefaultLocation = function() {
  return defaultLocation;
}
...
```

而 getter 和 setter 就可以完美的解决这个问题: 利用 Object 中的 defineProperty 方法进行操作.

```javascript
Object.defineProperty(this, 'defaultLocation', {
        get: function() {
            return defaultLocation;
        },
        set: function(value) {
            defaultLocation = value;
        }
    })
```

其中 defineProperty 有几个参数: 第一个参数决定作用在哪一个对象上, 第二个是用来访问 getter 和 setter 的变量名, 第三个写包含 getter 和 setter 的对象. 可以只写 getter 意味着这个值只读不能修改会报错, 也可以只写 setter 意味着只能修改不能读...

之后就可以在外部对这些变量进行访问了, 简单方便.

```javascript
const c = new Circle(10);
console.log(c.defaultLocation);
c.defaultLocation = { x: 1, y: 2};
console.log(c.defaultLocation);
```

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-4-get-private-with-getter.png)

这个例子的完整代码

```javascript

function Circle(raduis) {
    let color = 'red';

    this.radius = raduis;

    defaultLocation = { x: 0, y: 0};

    this.computeOptimumLocation = function (factory) {

    }
    this.draw = function() {
        this.computeOptimumLocation(0.1);
        console.log('draw');
    };

    Object.defineProperty(this, 'defaultLocation', {
        get: function() {
            return defaultLocation;
        },
        set: function(value) {
            defaultLocation = value;
        }
    });
}

const c = new Circle(10);
console.log(c.defaultLocation);
c.defaultLocation = { x: 1, y: 2};
console.log(c.defaultLocation);
```



下次写一下有关 JavaScript 中的 prototype (模板). 
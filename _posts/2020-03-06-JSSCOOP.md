---
layout: post
title: JavaScript 作用域和闭包
date: 2020-03-06 23:08:00 +0800
authorize: Daren
categories: JavaScript
nutshell: 这东西绝对是 JS 里面的一个大坑
---

## 1. 作用域(Scope)

### 1.1 全局作用域 (Global Scope)

在浏览器中, 全局作用域是在所有大括号(Clery braces)之外的作用域. Node 中的全局变量由于运行环境不同和浏览器中不一样, 这里不做讨论. 

同样的, 由于函数是变量, 声明在全局作用域的函数可以相互调用.(这个很容易比理解).

当使用全局变量的时候, 这个变量可以在所有位置进行访问, 包括各种函数中, 所以为了避免命名冲突, **尽量避免使用全局变量** 

当你使用 let 和 const 声明全局变量的时候, 变量名冲突会报错.

当你使用 var 声明全局变量时, 变量名冲突时会进行覆盖操作, 这使得很难进行 debug 

所以你应该多用局部变量, 而不是全局变量.

### 1.2 局部作用域 (Local Scope)

顾名思义, 局部作用域就是在代码的局部起作用的作用域. 声明在局部作用域的变量成为局部变量. 

局部变量有很多种. 

#### 1.2.1 函数作用域 (Function Scope)

既然函数内部是局部作用域, 那么当函数被调用的时候发生了什么?

- JavaScript 创建了一个新的运行环境, 这个运行环境是局部的, 也就是「局部作用域」
- 这个局部的运行环境将会拥有自己的变量, 这些变量就是这个局部作用域中的局部变量
- 新的运行环境将会被抛进运行栈(Execution Stack). 你可以把运行栈看作持续追踪运行环境的机器.

那么当函数结束之后发生了什么呢?

- 局部运行环境从运行栈(Execution Stack)中 POP 掉了
- 函数把返回值交给调用函数的上文(calling context). 之后就是之前调用函数的 calling context 来使用返回值了, 如果你没有写返回值, 那么返回的就是`undefined`
- 局部运行环境被摧毁(Destroyed)了, 其中声明的所有变量都被清除, 不再可用. 这就是本称作局部变量的原因(局部没了变量也没了), 你从外部导入的参数并不会对外面的原值产生影响.

所以, 在函数内部声明的变量只能在函数内部进行访问. 

```javascript
function sayHello() {
  const hello = 'hello Reader!';
  console.log(hello);
}
sayHello(); // 这里能正常访问
console.log(hello); // 这里就会报错
```



#### 1.2.2 块作用域 (Block Scope)

块语句(Block statement) 用来将一组语句打包成一组代码,  可以有可选的标签. 实际上, `if`语句中的代码块就是块语句,

实际上块作用域就是匿名函数拥有隐藏(implicit)返回的一种自集.

```javascript
if (true) {
  var x = 2;
}
{
  var name = 'hei';
}
```

MDN有关块语句的介绍: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block

总之还是那句话, 块作用域是匿名箭头函数隐藏返回值的一种特殊情况, 本质上还是函数. 所以当你用大括号(curly braces)把变量包裹起来的时候, 包起来的变量只能在大括号(curly braces)之内使用.

```javascript
{
  const hello = 'Hello';
  console.log(hello);
}
console.log(hello); // 这样会报错
```

#### 1.2.3 函数提升(hosited)与作用域

当声明函数的时候, 该函数会被提升到当前作用域的顶端, 这意味着调用函数可以在声明函数之前. 所以不管是你把函数声明写在前还是写在后, 这两个本质上是一样的.

```javascript
sayHello(); // 和下面的调用等效
function sayHello() {
  console.log('Hello. reader');
}
sayHello(); // 和上面的调用等效
```

但是要注意的是函数表达式(Function Expression)不同于函数声明(Function Declaration), 函数表达式声明的函数并不会提到最顶端.

```javascript
hello(); // 这样不可以
const hello = function() {
  console.log('Hello');
}
hello(); // 可以运行
```

有关这个函数表达式(Function Expression) 和 函数声明 (Function Declaration), 绝对是 JS 的一个大坑. 后面还有文章会讲到这个.

#### 1.2.4 函数无法访问其他的作用域

函数内不能访问其他的作用域, 即使你调用了另一个函数, 也不意味着你能访问他的变量. 这就是封装(Encapsulation)

```javascript
function first () {
  const firstFunctionVariable = `I'm part of first`
}

function second () {
  first(); // 别惊讶为什么这里可以调用前面的函数, 人家定义在全局作用域里呢
  console.log(firstFunctionVariable) 
}
```

#### 1.2.5 巢(Nested)作用域

你要是在一个函数里面定义了另一个函数, 那么里面这个函数就能访问上一级函数的变量了, 

这种行为被称作词义作用域(Lexical scoping)

```javascript
function outerFunction() {
  const outer = 'Im the outer function';
  function innerFunction() {
    const inner = 'Im the inner function';
    console.log(outer); // 可以这么做
  }
  console.log(inner); // 不允许这么做
}
```

虽然可以从内部访问外部的变量, 但是外部是无法访问函数内部的变量的.

你可以把这个想象成单面玻璃, 只能从一面透光

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/one-way-glass.png)

当你有多层函数的时候, 就好比好几层单面玻璃.

![](https://raw.githubusercontent.com/heidaren0000/blogGallery/master/glass-layers.png)

现在你已经知道了什么是作用域(scope)了, 所以我们来看看什么是 closure(闭包).

## 2. 闭包 (Closure)

为什么在函数内部可以访问外层的变量呢? JS 的这个特性相比其他语言是在是太怪异了. 而这一个原理的实现, 就是用了闭包的原理.

简而言之, **函数包裹在闭包之中**, 向外导出函数, 实际上导出的就是这个内部函数, 以及这个函数词义作用域的整体的引用. 函数和外部的一层词义作用域就是一个闭包. 而在函数内用到的外部变量因为是引用的关系会出现在闭包中. 如果你在函数外修改了函数内部用到的外部变量(有点绕啊这个). 闭包中的相应变量也会在函数执行前进行改变, 这个特性除了实现了全局变量, 还让 JS 有了一些令人难以理解的怪异的使用方式.

```javascript
function outter(){
  outVar = 1;
  const inner = function() {
    console.log(outVar);
  }
  return inner();
}
const test = outter();
test();

// 大家猜猜控制台能不能输出 outVar?
```

在上面的例子里面, 虽然在函数`outter()`执行完毕之后, 函数体包括里面的变量都被销毁了, 但是返回值返回的函数定义经过执行之后还是能够继续输出 `1`. 

这是因为返回的时候不仅仅返回了函数的定义本身, 同时还返回了这个函数的闭包(closure), 闭包中的相应变量还是维持上层函数`outVar`的值, 没有被销毁, 所以还可以继续访问, 甚至还可以进行修改.

另外, 我们给函数导入的参数, 也是通过闭包实现的. 与直接访问不同, 参数是间接访问, 对参数进行修改并不会影响外部的值, 而使用直接访问上层变量的话, 则会尝试修改上层函数中变量的值.


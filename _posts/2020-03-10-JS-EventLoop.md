---
layout: post
title: JavaScript Event Loop
date: 2020-03-10 12:09:00 +0800
authorize: Daren
categories: JavaScript
nutshell: JS 单线程异步的实现原理
---

鉴于我接触 JS 也才半年的时间, 写这些比较深入的原理难免会有差错, 所以如果你发现了文中有疏漏的地方, 望指教.

## 1. 开始

我们说 JavaScript 是单线程语言, 但是却能够异步执行代码, 而且这个线程不仅负责 JS 引擎, 还负责 DOM, 网页渲染... 这是怎么办到的呢? 靠的就是 Event Loop, 

- 调用栈 (Call Stack)
- 回调队列 / 任务队列 (Callback Queue / Task Queue)
- 微任务 (Microtask)
- DOM 渲染 (Render) (今天不聊这个, 这个我也不会😂)

线程就是在这些结构之间反复横跳, 最终呈现了一个完整的网页.

单纯的 JS 引擎并没有想象中那么多工作.  如果你对 JS 引擎拆包检查, 你会发现其中并没有与 setTimeout, DOM, 也没有 HTTP 的内容, 实际上这些功能的实现是靠的 JS 运行环境中的 WebAPI 实现的, Node 中类似的是 C++ API. 

## 2. 调用栈 Call Stack

一个线程 = 一个调用栈 = 同时执行一个任务

调用栈用来存放当前正在执行的 JS 函数, 总是有一个 main 函数在栈底

假设我们有这样的代码:

```javascript
function a() {
  console.log('hello');
}
function b() {
  a();
} 
function c() {
  b();
}
c();
```

运行时我们的调用栈是这样的

- 把 `c()` 压入栈中
- 把 `b()` 压栈
- 把 `a()` 压栈
- 输出 hello
- `a()`出栈
- `b()`出栈
- `c()`出栈

当前的调用栈就空了, 当栈空时, Event Loop 就会继续循环到下一个地方.

如果调用栈不空呢, 比如中间出现了一个无限循环? 整个页面就会因此卡住, 陷入 `阻塞(Block)`. 这个时候线程会被困在调用栈中出不来了. 你的渲染, 或者其他 Event Loop 元素都会卡住. 网页就没响应了.

另外还有一点就是为什么我们在 Debug 的时候要使用 Error 对象呢, 根本原因就是这个对象中不只包含了当前的信息, 同时还会返回整个调用栈, 一目了然, 比 `console.log()` 上一个一个试效率高太多了.

为了避免阻塞的发生, 我们需要将某些事件开销大的操作来异步执行. 

## 3. 解决之道: 异步 & 回调

我们都知道怎么使用 JS 中的异步和回调 实际上异步总是在同步代码发生之后执行, 如果我们用 `setTimeout()` 的话会结果会在规定时间后出现. 但是诡异的地方又来了: 异步执行的函数的结果是怎么突然出现在调用栈中的. 他是什么时候来的, 是谁算出来的?

当`setTimeout()`这样的函数在执行时, 会直接让浏览器的 WebAPI 来接管, 存放到浏览器的 Event Table中, 同时出栈. 所以其实是浏览器在帮忙. 这也难怪为什么 JS 引擎的源码中没有跟 `setTimeout()` 沾边的东西.

那么浏览器执行完之后想要把回调函数重新交给 JS 怎么办呢? 浏览器可不能破坏你的代码, 如果当完成之后直接给调用栈的话, 那么你的回调就会随机出现在代码的任何位置. 这个简直是灾难. 所以为了避免这种情况发生, WebAPI 会把回调函数放进回调队列(Callback Queue), 等到时机成熟, 调用栈空之后再返回到栈里.

## 4. 任务 Task

用来存放异步执行的回调, 当 Event Loop 运行到这里时, 一个一个的执行, 如果中间又来了新的 JS, 那么会被打断, 不会造成阻塞.

## 5. 微任务 Microtasks

微任务可以用来检查某些状态, 比如 DOM 状态是否发生了改变, 以及异步是否执行完成等等. 实际上 Promise 就是微任务的一种. 无需担心 Promise 会被从栈中清理掉, 因为他也是栈底的一部分. 每当 JS 执行完之后都会执行微任务.

与任务不同的是, 当前微任务会一次执行完, 后来的微任务也在当前周期执行. 这个就比较恐怖了, 如果微任务太多的话会造成阻塞

```javascript
function loop(){
  Promise.resolve().then(loop);
}
loop();
```

## 6. 使用 setTimeout 函数时发生了什么

- 调用栈将回调函数交给了浏览器的 WebAPI, 当前调用栈出栈
- setTimeout 完成之后将回调函数放到回调队列(Call Queue)中
- 如果调用栈空, 将回调函数取出放入调用栈中. 

就这么简单. 从这个例子, 我们也能看出, setTimeout 的回调时间并不是精确的, 而是回调的最快时间.

## 7. 渲染

实际上浏览器中的渲染用和 JS 引擎是同一个线程. 所以渲染也是 Event Loop 的一部分. 浏览器中的网页在理想的无阻塞条件下每 16.6 毫秒重新渲染一次, 对应 60 帧. 当前的返回栈中有代码没有执行完, 会造成丢帧.

当阻塞发生时, 整个网页的渲染也会失被阻塞而去响应, 这就是为什么之前阻塞后网页无响应的原因.

在渲染上还有很多高阶的操作, 比如你可以定义 JS 动画之类的, 还能用特殊的方法修改 Event Loop 的运行顺序等等,  这里就不深入讨论了.
<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>NodeJS(二) 组件(Modules) | Daren’s Daliy</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="NodeJS(二) 组件(Modules)" />
<meta name="author" content="黑大任" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 全局对象 (Global Object)" />
<meta property="og:description" content="1. 全局对象 (Global Object)" />
<link rel="canonical" href="http://localhost:4000/node/2020/02/18/NodeJS(2)-Modules.html" />
<meta property="og:url" content="http://localhost:4000/node/2020/02/18/NodeJS(2)-Modules.html" />
<meta property="og:site_name" content="Daren’s Daliy" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-18T15:01:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/node/2020/02/18/NodeJS(2)-Modules.html","headline":"NodeJS(二) 组件(Modules)","dateModified":"2020-02-18T15:01:00+08:00","datePublished":"2020-02-18T15:01:00+08:00","author":{"@type":"Person","name":"黑大任"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/node/2020/02/18/NodeJS(2)-Modules.html"},"description":"1. 全局对象 (Global Object)","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Daren's Daliy" /></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Daren&#39;s Daliy</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Posts</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">NodeJS(二) 组件(Modules)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-02-18T15:01:00+08:00" itemprop="datePublished">Feb 18, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="1-全局对象-global-object">1. 全局对象 (Global Object)</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span> <span class="c1">// Global Object</span>
</code></pre></div></div>

<p>我们之前常用的 <code class="highlighter-rouge">console.log()</code> 函数可以在任何位置被访问, 不管是函数外还是函数内, 像这种在任何位置都能进行访问的对象, 这些对象是全局作用域(Global Scope)的一部分,   叫做全局对象(Global Object).</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="err">在</span> <span class="nx">JavaScript</span> <span class="err">中有这些常用的全局对象</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>
<span class="nx">setTimeout</span><span class="p">();</span> <span class="c1">// 用来设置暂停</span>
<span class="nx">clearTimeout</span><span class="p">();</span> <span class="c1">// 用来清除暂停</span>

<span class="nx">setInterval</span><span class="p">();</span> <span class="c1">// 用来设置间隔来重复执行函数</span>
<span class="nx">clearInterval</span><span class="p">();</span> <span class="c1">// 取消重复执行</span>
<span class="c1">// 在浏览器中的 window 对象代表了整个全局作用域.</span>
<span class="c1">// 所有的全局对象前面都可以加一个 window. 因为这些对象就定义在 window 里面</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="dl">''</span><span class="p">;</span> <span class="c1">// 由于声明的是全局的, 也可以用window 访问</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">message</span><span class="p">;</span>
</code></pre></div></div>

<p>但是在 Node 中, 并没有和 <code class="highlighter-rouge">window</code>对象, 取而代之的是 <code class="highlighter-rouge">global</code> 对象.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">global</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">();</span>
<span class="nb">global</span><span class="p">.</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>
</code></pre></div></div>

<p>另一个不同的地方是, 变量并没有被定义在<code class="highlighter-rouge">global</code>中, 而是被定义在了当前写代码的的 .js 文件中, 比如我例子里的是 <code class="highlighter-rouge">app.js</code> , 这是由于 Node 的模块系统(Module System).</p>

<h2 id="2-模块-modules">2. 模块 (Modules)</h2>

<p>上一节说到, 在浏览器中创建的所有的全局变量, 最终都是定义在 JS 运行环境中的<code class="highlighter-rouge">window</code> 对象中, 但是这里有一个显而易见的问题: 在复杂的开发中, 需要将一个网站的 JS 文件分解成多个 JS 文件, 由于 <code class="highlighter-rouge">window</code> 的存在, 我们无法在不同的文件中使用相同的对象名或者变量名, 否则<code class="highlighter-rouge">window</code>中的对象就会被覆盖, 这就比较麻烦了. 这就是为什么, 在最新的 ES6 标准中, 出现了 <code class="highlighter-rouge">let</code> 来定义块作用域的变量, 而没有人推荐你再使用 <code class="highlighter-rouge">var</code> 来声明全局变量了.</p>

<p>在 NodeJS 中, 为了避免这个问题, 出现了模块化的概念(Modularity), 你在独立文件中声明的全局变量, 并不会上升到 <code class="highlighter-rouge">global</code> 对象中, 而是在当前 JS 文件的作用域中, 限制在当前模块(Module)中. 这就避免了对象被覆盖的问题.</p>

<p>在 Node 中的每一个文件都被视为一个模块(Module), 定义在这个文件里的变量或者对象都被限制在文件作用域中, 并且是不能从外部访问的私有变量和私有对象, 模块之间都是彼此隔离的. 如果要从外部访问, 需要特别操作.</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/2-0-modules.png" alt="" /></p>

<p>而在 NodeJS 中, 需要用一个模块(Module)来调起其他的模块, 这个模块被称为“主模块(Main Module)”. 可以类比 C 语言中用来调起其他函数的“主函数(Main Function)”.</p>

<p>模块的相关信息都存储在自身的 <code class="highlighter-rouge">module</code> 对象中, 可以用 <code class="highlighter-rouge">console.log()</code> 来输出.</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/2-1-module-object.png" alt="" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MacBook-Pro:NodeJS daren<span class="nv">$ </span>node app.js
Module <span class="o">{</span>
  <span class="nb">id</span>: <span class="s1">'.'</span>, <span class="c"># 每个模块都有唯一ID 作为识别标识</span>
  exports: <span class="o">{}</span>, <span class="c"># 用来导出某些对象</span>
  parent: null,
  filename: <span class="s1">'/Users/daren/Desktop/NodeJS/app.js'</span>, <span class="c"># 文件的完整路径</span>
  loaded: <span class="nb">false</span>, <span class="c"># 决定是否加载</span>
  children: <span class="o">[]</span>,
  paths:
   <span class="o">[</span> <span class="s1">'/Users/daren/Desktop/NodeJS/node_modules'</span>,
     <span class="s1">'/Users/daren/Desktop/node_modules'</span>,
     <span class="s1">'/Users/daren/node_modules'</span>,
     <span class="s1">'/Users/node_modules'</span>,
     <span class="s1">'/node_modules'</span> <span class="o">]</span> <span class="o">}</span> 
</code></pre></div></div>

<p>## 3. 新建模块 (Creating Module)</p>

<p>假设我们有了一个 logger 模块, 用来记录 Node 项目用来运行时的某些信息.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://mylogger.io/log</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Pretending Send HTTP request</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是这么一个模块里面的都是私有对象, 怎么被主模块导入呢?</p>

<p>这就需要用到刚才在<code class="highlighter-rouge">module</code>对象中看到的 <code class="highlighter-rouge">export</code> 对象了, 这个对象的作用就是把某些内容导出. 直接修改这个<code class="highlighter-rouge">module.export</code>对象即可.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">log</span> <span class="o">=</span> <span class="nx">log</span><span class="p">;</span>
<span class="p">...</span>

</code></pre></div></div>

<p>或者你可以直接把一个对象引用过去…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">log</span><span class="p">:</span> <span class="nx">log</span>
<span class="p">}</span>
</code></pre></div></div>

<p>本质上, Module 之间的传值, 就是 JSON.</p>

<p>这么做的目的, 就是通过 Module 的封装将整个 JS 文件抽象化, 你可以直接使用而不必研究内在的逻辑. 好比一台 DVD 播放机, 你只需要按下按钮就可以播放, 而不需要搞懂里面的所有部件. Module 就是 DVD 播放机, export 就是按钮, 是播放机的公共接口.</p>

<h2 id="4-加载模块-load-modules">4. 加载模块 (Load Modules)</h2>

<p>在 exports 模块的某些内容之后, 我们还需要主模块中对其他模块导出的内容进行导入. 这里要用到的是<code class="highlighter-rouge">require()</code>方法, 这个方法只有一个参数, 那就是需要导入的模块的路径, 而执行完成之后的返回值是一个对象, 直接可以赋值给其他对象.</p>

<p><strong>app.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./logger.js</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./logger</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 这样也可以</span>
<span class="nx">logger</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>如果你的 Module 值 export 了一个方法, 你甚至可以直接将方法赋值给<code class="highlighter-rouge">module.export</code>, 因为函数本身也是一种对象.这么做的好处是, 你不必再通过 dot notation 就能直接访问到方法.</p>

<p>另外一个需要注意的地方就是, 为了避免导入的对象或者变量被不小心覆盖掉, 最好把 <code class="highlighter-rouge">require()</code>赋值给 <code class="highlighter-rouge">const</code> 类型的静态变量, 防止被修改.</p>

<p><strong>logger.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">log</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<p><strong>app.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./logger.js</span><span class="dl">'</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div>

<h2 id="5-模块打包函数-module-wrapper-function">5. 模块打包函数 (Module Wrapper Function)</h2>

<p>每个 Module 内部的变量都是私有的, 并且无法从外部进行访问. 打包函数与每个 Module 的私有化实现有关.</p>

<p>每个 JS 文件中写的内容, 在通过 Node 执行时, 都会被自动包(Wrapper) 进一个打包函数中.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">exports</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">module</span><span class="p">,</span> <span class="nx">__filename</span><span class="p">,</span> <span class="nx">__dirname</span><span class="p">)</span> <span class="p">{</span>
  
<span class="p">});</span>
<span class="c1">// 以上为打包函数,</span>
<span class="cm">/*
	其中的参数:
	exports: module.exports 的引用, 所以直接访问 exports 和访问 modules.exports 是等效的.
	由于这是 module.exports 的引用, 所以不能跟刚才一样直接把要导出的函数引用给他, 不然就乱套了😂.
	
	require: 之前我们用来把 exports 赋值的函数. 
	你可能以为这个是属于global对象的全局函数, 其实它还是局部的.
	每个 Module 的 require() 都是作为打包函数参数被导入的本地函数.
	module: 就是之前用过的 module 对象.
	
	__filename: 包含完整绝对路径的文件名
	__dirname: 完整绝对路径 
	
*/</span>
</code></pre></div></div>

<p>在运行时(Runtime), 我们的代码会变成这个样子:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">exports</span><span class="p">,</span> <span class="nx">require</span><span class="p">,</span> <span class="nx">module</span><span class="p">,</span> <span class="nx">__filename</span><span class="p">,</span> <span class="nx">__dirname</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://mylogger/log</span><span class="dl">'</span><span class="p">;</span>
	<span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">message</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>实际的代码还要比这个复杂一点, 如果你是 JS 大佬, 可能会看出来这个写法是“立即执行函数表达式(Immediately-Invoked-Function-Expression aka.IIFE)”.</p>

<p>所以 Node 并不是直接执行我们的代码, 代码总是被包裹在打包函数里, 由于这个是匿名函数, 所以里面的变量都变成私有的了.</p>

<p>同时呢, 除了你自己写的 Module 呢, Node JS 自带了很多很牛逼的 Module. 都写在官方的 Doc 里.</p>

<h2 id="6-路径模块path-module">6. 路径模块(Path Module)</h2>

<p>这里拿 Path Module 来举个例子. 首先我们从官网的 Doc 查到了这个 Module 有一个 parse 方法:</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/6-1-path-parse-module.png" alt="" /></p>

<p>然后我们导入这个 module</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 注意这里导入自带 module 的方式是直接写上 module 的名字, 而不是路径, 当找不到自带的 module 时, Node 会查找相关的文件</span>
<span class="c1">// 如果你要导入项目中的同名 module , 可以直接导入这么写:</span>
<span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./path</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>之后就可以直接使用这个函数了:</p>

<p><strong>app.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">path</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">__filename</span><span class="p">));</span>
</code></pre></div></div>

<p><strong>bash</strong></p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/6-2-path-parse-inBash.png" alt="" /></p>

<p>另外, 这些自带的 module 也是非常重要的:</p>

<ul>
  <li>File System: 和文件系统进行交互</li>
  <li>HTTP: 用来搭建简单的 HTTP 服务</li>
  <li>OS: 用来与系统交互</li>
  <li>Path: 用来操作路径</li>
  <li>Process: 与进程相关的 module</li>
  <li>Query Strings: 处理队列, 在 HTTP 服务器中会用到</li>
  <li>Stream: 流处理</li>
</ul>

<h2 id="7-os-模块os-module">7. OS 模块(OS Module)</h2>

<p>OS 模块能实现的特性, 是运行在浏览器中的 JS 绝对不能企及的, 借助 OS 模块, 可以方便的与操作系统进行交互.</p>

<p><strong>app.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">os</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">os</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">totalMemory</span> <span class="o">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">totalmem</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">freeMemory</span> <span class="o">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">freemem</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Total Memory: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">totalMemory</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>bash</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MacBook-Pro:NodeJS daren<span class="nv">$ </span>node app.js
Total Memory: 17179869184
MacBook-Pro:NodeJS daren<span class="nv">$ </span>
</code></pre></div></div>

<h2 id="8-文件系统模块file-system-module">8. 文件系统模块(File System Module)</h2>

<p>文件系统模块主要用来使用各种文件, 用来和文件系统进行交互. 在使用的时候, 很多方法都是成双出现的</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/7-1-fs-object-list.png" alt="" /></p>

<p>其中以 <code class="highlighter-rouge">sync</code> 结尾的就是同步(synchronous), 阻断(block) 类型的方法, 而没有 <code class="highlighter-rouge">sync</code> 结尾的就是非同步(asynchronous)类型的方法.</p>

<p>虽然参数简单, 但是注意要谨慎使用同步方法, 因为 node js 是单线程执行的, synchronous 类型的方法会放大时间开销.</p>

<p>而异步版本的方法都需要回调函数(callback), 这个函数将在相应的异步方法执行完成后执行.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">dir</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">./</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">dirAsynchronous</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readdir</span><span class="p">(</span><span class="dl">'</span><span class="s1">./</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">file</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="k">else</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div></div>

<p>这里有一个坑就是, 异步的函数没有返回值, 但是可以通过回调函数进行赋值的操作. 而具体回调函数需要哪些参数, 还是要依据文档为准.</p>

<h2 id="9-事件组件-events-module">9. 事件组件 (Events Module)</h2>

<p>Node 中有一个十分重要的概念就是<strong>事件</strong>(Event). 实际上很多 Node 的核心功能都是基于事件来实现的.</p>

<p>简而言之, 事件(Event)就是一件事情发生的信号.</p>

<p>举个例子, 在 Node 中, 我们有一个 HTTP 类, 用来建立 web 服务, 所以我们需要监听某个端口(port), 而每次我们接收到请求的时候, HTTP 类机会产生新的事件(Event), 而我们要做的就是对这个事件进行响应(Response), 这就要读取这个请求, 然后返回.</p>

<p>所以这里就要介绍一下如何使用事件模块(Events Module).</p>

<p><em>注意: object 是 class 的实例</em></p>

<p>要使用事件, 有一个很重要的类叫做 Event Emitter, 里面提供了很多和事件相关的方法, 在官网的 Events 相关的 Doc 中能够查到.</p>

<p>虽然 EventEmitter 里面有一堆方法, 但是常用的据说就下面两个.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">events</span><span class="dl">'</span><span class="p">);</span> 
<span class="c1">// 注意命名规范, EventEmitter 首字母大写表示这个是类而不是对象</span>
<span class="c1">// class 里面有 property 和 method</span>
<span class="kd">const</span> <span class="nx">emitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="p">();</span>
<span class="c1">// object 是 class 的实例</span>
<span class="c1">// EventEmitter 定义了 Event Emitter 都能做什么, 而 object 就是 EventEmitter 的实例</span>

<span class="c1">// 下面要注册一个 Listener, Register a listener</span>
<span class="c1">// on 方法接受两个参数, 第一个是事件的名字, 第二个是回调函数, 也就是接收到事件的进一步行为.</span>
<span class="c1">// 要注意 Listener 一定要在 Emitter 之前, 不然 event 产生之后才进行监控就什么都没有了.</span>
<span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Listener called</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 下面注册的就是 Emitter</span>
<span class="nx">emitter</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// Raise an event, 这里产生了一个事件</span>
<span class="c1">// emit means Making a noise, produce - signalling</span>
<span class="c1">// 直白的说这个 emit 就是用来下产生 event 的, 里面的参数是 event 的名字</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/10-1-1-emiWithMessage.png" alt="" /></p>

<p>当 emitter 进行时, 会在所有已经注册的 listener 中进行遍历比对, 这个是同步执行的(synchronously). 所以如果 listener 在执行 emitter 之前还没有注册的话, 肯定是不能用的.</p>

<h2 id="10-事件参数-event-argument">10. 事件参数 (Event Argument)</h2>

<p><strong>看见参数用什么单词吗? Argument, 这个词专门指实参, 而 parameter 用于形式参数(形参), 有关编程的语言规范,请看http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</strong></p>

<p>当你发送某些事件的时候, 你可能希望同时包含这个事件的一些附加信息. 比如给你的事件加一个 ID, 或者带一个 URL 等等, 这就需要给 emitter 和 listener 添加参数了</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">events</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">const</span> <span class="nx">emitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="p">();</span>
<span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span> <span class="c1">// 这里的 args 导入的就是 emitter 的第二个参数</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Listener called</span><span class="dl">'</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">emitter</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://</span><span class="dl">'</span><span class="p">});</span> 
<span class="c1">// emitter 的参数你可以单独写, 但是最好放在同一个对象里更方便些, 具体分开怎么写暂时我也不知道😂</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/10-1-2.png" alt="" /></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">emitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">args</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Listener called</span><span class="dl">'</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
<span class="p">});</span> <span class="c1">// 你也可以用 ES6 里的 箭头匿名函数进行改写 Arrow method</span>
</code></pre></div></div>

<h2 id="11-继承-event-emitter-extending-eventemitter">11. 继承 Event Emitter (Extending EventEmitter)</h2>

<p>在实际的情况中, 很少直接使用 EventEmitter 更多的是将这个打包进了一整个新的 class 中. 这个比较难理解, 因为如果你在一个 Module 里用 Emitter, 另一个 Module 里用 Listener, 就接受不到了, 因为 Listener 只能接收跟他来自同一个 EventEmitter 对象的 Emitter, 两个 Module 之间两个 EventEmitter 显然就不行了.</p>

<p>为了解决这种情况, 一般的方式就是写一个类单独来继承 EventEmitter 类, 同时包含调用 emit() 的方法, 然后跑到想要用 Listener 的地方新建实例.</p>

<p><strong>app.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Logger</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(.</span><span class="o">/</span><span class="nx">logger</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Logger</span><span class="p">();</span>
<span class="nx">logger</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Listener called</span><span class="dl">'</span><span class="p">,</span> <span class="nx">arg</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>logger.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">events</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">class</span> <span class="nx">Logger</span> <span class="kd">extends</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">messageLogged</span><span class="dl">'</span> <span class="o">+</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">url</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://</span><span class="dl">'</span><span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="12-http-模块-http-module">12. HTTP 模块 (HTTP Module)</h2>

<p>这个模块用来建立HTTP连接</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">creatServer</span><span class="p">();</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">socket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// connection 参数 在 DOC 里面有  </span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection Established</span><span class="dl">'</span><span class="p">);</span>
<span class="p">})</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Listening port 3000</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>因为 http.Server 继承了 net.Server, 而 net.Server 本身就是一种 EventEmitter, 所以这里建立的 server 可以用 on, emit 这种方法, 但是这种方法也太底层了, 我们一般不会用到.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">creatServer</span><span class="p">((</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">Helloworld</span><span class="dl">'</span><span class="p">);</span>
   	<span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">/api</span><span class="dl">'</span><span class="p">){</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">Helloworld</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">socket</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection Established</span><span class="dl">'</span><span class="p">);</span>
<span class="p">})</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Listening port 3000</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p>所以可以简要概括成下面这几个动作:</p>

<ul>
  <li>导入Modules</li>
  <li>创建 server</li>
  <li>创建 Listener / 监听方法</li>
  <li>进行反馈</li>
</ul>

<p>而这样来进行路由显然费力不讨好, 网站太多根本就忙不过来. 所以我们也不会用这样的方式处理请求, 而是用 Express 框架.</p>

  </div><a class="u-url" href="/node/2020/02/18/NodeJS(2)-Modules.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Daren&#39;s Daliy</h2>
        <ul class="contact-list">
          <li class="p-name">黑大任</li>
          <li><a class="u-email" href="mailto:heidaren0000@gmail.com">heidaren0000@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>我们刚刚来到山脚. 前路漫漫, 可惜不是所有人都能够一览群山. We just at foot of mountain. It still a long way to go, what a pity that not everyone could up to the top.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>

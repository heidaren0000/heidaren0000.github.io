<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>JavaScript 面向对象 | Daren’s Daliy</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="JavaScript 面向对象" />
<meta name="author" content="黑大任" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="注意 JS 中首字母大写的函数一般都是系统函数, 或者自己定义的构造函数." />
<meta property="og:description" content="注意 JS 中首字母大写的函数一般都是系统函数, 或者自己定义的构造函数." />
<link rel="canonical" href="http://localhost:4000/javascript/2020/02/15/JSOOP.html" />
<meta property="og:url" content="http://localhost:4000/javascript/2020/02/15/JSOOP.html" />
<meta property="og:site_name" content="Daren’s Daliy" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-02-15T09:20:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/javascript/2020/02/15/JSOOP.html","headline":"JavaScript 面向对象","dateModified":"2020-02-15T09:20:00+08:00","datePublished":"2020-02-15T09:20:00+08:00","author":{"@type":"Person","name":"黑大任"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/javascript/2020/02/15/JSOOP.html"},"description":"注意 JS 中首字母大写的函数一般都是系统函数, 或者自己定义的构造函数.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Daren's Daliy" /></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Daren&#39;s Daliy</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Posts</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">JavaScript 面向对象</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-02-15T09:20:00+08:00" itemprop="datePublished">Feb 15, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>注意 JS 中首字母大写的函数一般都是系统函数, 或者自己定义的构造函数.</p>

<h2 id="介绍面向对象">介绍面向对象</h2>

<h3 id="四个核心概念">四个核心概念</h3>

<ul>
  <li>封装 Encapsulation</li>
  <li>抽象 Abstraction</li>
  <li>继承 Inheritance</li>
  <li>多态 Polymorphism</li>
</ul>

<p>像 C 这样的面向过程语言, 基本的组成元素是函数(function), 各个函数之间相互调用, 显得乱七八糟, 有人戏称为“意大利面代码(spaghetti code)”, 使用面向过程就可以有效避免混乱的情况发生</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-1-procedural-programming.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-2-spaghetti.png" alt="" /></p>

<p>面向对象就相当于把变量(variety)和函数(function)进行了分门别类的打包整理进了各种的类里, 变成属性(props) 和 方法(methods).</p>

<h4 id="封装--减少复杂性-增加复用性">封装 : 减少复杂性, 增加复用性</h4>

<p>类的不同实例彼此分离不影响, 好比现实中不同事物属性(property)和行为方法(method)也是彼此分离的. 这就是封装(Encapsulation)</p>

<p>下面的例子展示了同样的功能分别使用面向过程(POP)和面向对象(OOP)实现</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">baseSalary</span> <span class="o">=</span> <span class="mi">30</span><span class="nx">_000</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">overtime</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">rate</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">gatWage</span><span class="p">(</span><span class="nx">baseSalary</span><span class="p">,</span> <span class="nx">overtime</span><span class="p">,</span> <span class="nx">rate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">baseSalary</span> <span class="o">+</span> <span class="p">(</span><span class="nx">overTime</span> <span class="o">*</span> <span class="nx">rate</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">employee</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">baseSalary</span><span class="p">:</span> <span class="mi">30</span><span class="nx">_000</span><span class="p">,</span>
    <span class="na">overtime</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="na">rate</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">gatWage</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">baseSalary</span> <span class="o">+</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">overtime</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">rate</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">};</span>
<span class="nx">employee</span><span class="p">.</span><span class="nx">gatWage</span><span class="p">();</span> 
</code></pre></div></div>

<p>可以看到 OOP 的写法省掉了参数</p>

<h4 id="抽象--减少复杂性-减少冲突">抽象 : 减少复杂性, 减少冲突</h4>

<p>抽象的特性使得我们操作面向对象的操作跟操作一个 CD 机一样—根本不用在意内部在发生什么, 像一个黑箱一样, 内部的复杂机制都隐藏起来, 留一个接口, 他就能运行.</p>

<p>由于可以在不改变接口的情况下改变类内部的机制, 这个特性非常有用.</p>

<h4 id="继承--eliminate-redundant-code-减少冗余代码">继承 : eliminate redundant code 减少冗余代码</h4>

<p>像真的“继承”一样, 面向对象里的继承可以让你让一个子类继承父类的方法和属性, 之后还能修修补补, 添加新的特性, 提高代码的复用性.</p>

<h4 id="多态-polymorphism--refactor-ugly-switchcase-statemets-重构条件语句">多态 Polymorphism : refactor ugly switch/case statemets 重构条件语句</h4>

<p>Polymorphism 这个词很多老外看了都是一脸懵逼. 但是也不是很难理解. ‘poly’ 指的是 ‘many’, ‘morphism’ 指的是 ‘forms’, 直译过来就是 “形式很多”, “多态”. 面向对象的这个特性能让你省掉很多的 if-else 和 switch 语句, 因为这个特性可以只让符合条件的元素进行加载.</p>

<h2 id="对象-object">对象 Object</h2>

<h3 id="创建对象-creating-objects">创建对象 Creating Objects</h3>

<p>下面的写法叫 object literal syntax (对象文本参数)</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">radius</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">location</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">y</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">},</span>
    <span class="na">draw</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">draw</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">circle</span><span class="p">.</span><span class="nx">draw</span><span class="p">();</span>
</code></pre></div></div>

<p>如果运行的话, 会在 console 中看到 ‘draw’.</p>

<p>这就简单的定义了一个对象.</p>

<p>如果你觉得上面的 <code class="highlighter-rouge">cricle</code> 对象不错, 要重新建立一个 circle 对象, 那么除了复制粘贴(要是复制的好几十个之后才发现错误, 那你只能一个一个进行修改了), 还可以用工厂函数(Factories)或者构造函数.</p>

<h3 id="工厂函数和构造函数-factories-and-constructors">工厂函数和构造函数 Factories and Constructors</h3>

<h4 id="工厂函数-factories-function">工厂函数 Factories Function</h4>

<p>简单的来理解, 这个工厂函数的作用就是像一个工厂一样.每次执行的时候都会“造”一个对象出来.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createCricle</span><span class="p">(</span><span class="nx">radius</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">radius</span><span class="p">,</span>
        <span class="na">draw</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">draw</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">createCricle</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">circle</span><span class="p">.</span><span class="nx">draw</span><span class="p">();</span>
</code></pre></div></div>

<p>现在就可以随心所欲的创建对象了.</p>

<p>本质上, 工厂函数使用的是 object liberty syntax 对象字符参数来创建对象直接返回了一个对象, 没有动 js 原生的构造函数.</p>

<h3 id="构造函数-constructors">构造函数 Constructors</h3>

<p>构造函数的首字母需要大写, 同时需要使用 new 运算符</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Constructor Function</span>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">raduis</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">raduis</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">draw</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="kd">const</span> <span class="nx">another</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>需要注意的是 Javascript 中没有 class 的概念的, 但是貌似 Node 中有</strong></p>

<p>new运算符会执行下面的操作:</p>

<ul>
  <li>创建一个空的对象 {}</li>
  <li>将构造函数内的 this 指向刚刚创建的空对象里.</li>
  <li>从构造函数里面返回对象(如果你没有给构造函数写明切的 return, 默认返回的就是 return this「也就是对象」, Java 或者 C++ 的构造函数跟这里不一样的是他们构造函数没有返回值)</li>
</ul>

<p>由于 new 的缘故, 构造函数里的 this 值都指向新的空对象了, 默认情况下 this 指向的是浏览器里的 window 对象(也就是说你要是不加 new 的话, 直接操作的就是 window 对象, 里面的对象在哪都能访问)或者 NodeJS 的 GLOBAL.</p>

<p>本质上, 构造函数就是对对象默认的 constructor properties 进行覆盖 override</p>

<p>不论是工厂函数还是构造函数, 都是标准的 JavaScript 函数, 而且效果都是相通的. 有不同语言习惯的人用的就是自己习惯的写法来写构造函数.</p>

<p>对于会 C++ 和 Java 的同学来说, 构造函数用起来比较习惯</p>

<h3 id="构造函数属性-constructor-property">构造函数属性 Constructor Property</h3>

<p>每一个 JS 对象都有一个 构造器属性 Constructor Property 用来构造或者创建对象, 如果你在浏览器的 console 中运行 <code class="highlighter-rouge">对象.constructor</code> 这样的话就会在控制台显示这个对象的构造器属性. 要注意这个只有构造函数才会有, 工厂函数创建的构造函数属性还是默认的构造函数属性, 即空属性.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 构造函数创建的对象, 其中有自定义构造函数属性</span>
<span class="nx">another</span><span class="p">.</span><span class="kd">constructor</span>
<span class="err">ƒ</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">raduis</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">raduis</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">draw</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="c1">// 工厂函数创造的对象, 其中没有自定义的构造函数属性, 是默认的构造函数属性</span>
<span class="nx">circle</span><span class="p">.</span><span class="kd">constructor</span>
<span class="err">ƒ</span> <span class="nb">Object</span><span class="p">()</span> <span class="p">{</span> <span class="p">[</span><span class="nx">native</span> <span class="nx">code</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>每一个对象都具有构造函数属性, 默认的构造器属性是空方法, 如果是继承的构造函数, 看这个https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor</li>
  <li>构造函数属性是隐藏的, 需要单独访问<code class="highlighter-rouge">对象.constructor</code> 才能查看呢</li>
  <li>如果你用了自己写的构造方法, 那么默认的构造器属性就会被你的方法覆盖.</li>
  <li>由于 JavaScript 的面向对象属性, 实际上类型的变量创建也会调用 JavaScript 引擎相应的构造器, 举个例子:</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1">// js 引擎实际上会把这个翻译成: </span>
<span class="c1">// let x = new Object(); </span>
<span class="dl">''</span><span class="p">,</span> <span class="dl">""</span><span class="p">,</span> <span class="s2">``</span>
<span class="c1">// 这三个会被使用 new String();</span>
<span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
<span class="c1">// 这两个会使用 new Boolean();</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">...</span>
<span class="c1">// 这个会使用 new Number();</span>
<span class="p">....</span> 
</code></pre></div></div>

<p>###函数其实是对象 Functions are Objects</p>

<p>很多人都对此感到疑惑, 但是事实如此, JS 中的函数和对象一样具有各种属性, 比如可以直接在 console 中访问函数对象的属性, 甚至还有构造函数.</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-1-FunctionObjecr.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-2-FunctionObjectorConstructor.png" alt="" /></p>

<p>实际上, 函数对象调用的就是函数的构造方法 <code class="highlighter-rouge">Function()</code>, 其中第一个函数是参数, 第二个参数就是函数的语句, 函数语句在构造函数中被解析</p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-3-FunctionObjectConstructorSyntx.png" alt="" /></p>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-4-afterFunctionConstruction.png" alt="" /></p>

<h4 id="构造函数的缺省方法">构造函数的缺省方法</h4>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-3-5-what-available-in-construction.png" alt="" /></p>

<p>图片里面的紫色小框开头的就是构造函数的缺省方法, 而蓝色的值的是构造函数对象内的属性.</p>

<p>举个例子:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Circle</span><span class="p">.</span><span class="nx">call</span><span class="p">({},</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>call 方法会把 this 定向到第一个参数的对象里, 然后后面的参数就是要传入的参数, 如果你有多个参数的话, 直接在后面接上就行. 这个产生的结果跟使用 new 运算符相同.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Circle</span><span class="p">.</span><span class="nx">apply</span><span class="p">({},</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div></div>

<p>apply 方法的效果和前面的 call 一样, 不同之处在于它的第二个参数是数组, 如果有多个参数的话直接吧参数导入到数组就可以. 不同于 call 方法的每个待传入构造函数的的参数分别占据一个参数的位置. 这个方法在你已经有一个现成数组的时候特别好用.</p>

<h3 id="原始类型和引用类型-primitives-and-reference-types">原始类型和引用类型 Primitives and Reference Types</h3>

<p>js 中分成下面两种类型: Value Types (值类型) Reference Types(引用类型), 理解这些类型特别重要,</p>

<p>Value Types:</p>

<ul>
  <li>Number</li>
  <li>String</li>
  <li>Boolean</li>
  <li>Symbol</li>
  <li>undefined</li>
  <li>null</li>
</ul>

<p>Reference Types</p>

<ul>
  <li>Object</li>
  <li>Function</li>
  <li>Array</li>
</ul>

<p>Primitives are copied by their value</p>

<p>Objects are copied by their reference</p>

<p>虽然函数本身是引用类型, 但是传递参数的时候会根据参数自己本身的类型来决定是直接传递(传递引用)还是间接传递(传递值).</p>

<p>如果是像 Number 这种值类型的数据, 就会把参数复制一份, 给函数自己的本地变量, 这样内外都互不影响.</p>

<p>如果传递的是 Object 这种引用类型的数据, 相应的操作就是传递参数的引用, 这样在函数内部对传入的参数进行了修改, 函数外也会受到影响.</p>

<h3 id="属性-working-with-properties">属性 Working with Properties</h3>

<h4 id="添加删除属性-addingremoving-properties">添加/删除属性 Adding/Removing Properties</h4>

<h5 id="添加属性">添加属性</h5>

<p>如果你从客户端取回一堆 JSON 之后想要继续添加一些属性,   比如 tocken 这种, 就需要添加属性了.</p>

<p>添加属性的方式很简单, 直接赋值就可以, JS 会自动帮你把这个添加到对象里.</p>

<p>添加有两种表示方法: 括号表示法(bracket notation)和点表示法(dot notation), 这两种方法在访问</p>

<h5 id="点表示法dot-notation">点表示法(dot notation)</h5>

<ul>
  <li>用<code class="highlighter-rouge">.</code>来访问属性</li>
  <li>属性名称中不能出现特殊符号和空格</li>
  <li>不能将变量作属性名</li>
</ul>

<h5 id="括号表示法bracket-notation">括号表示法(bracket notation)</h5>

<ul>
  <li>用<code class="highlighter-rouge">[ ]</code>来访问属性</li>
  <li>允许属性名称中使用特殊符号和空格</li>
  <li>可以在里面使用变量来给属性进行动态命名.</li>
</ul>

<h5 id="删除属性">删除属性</h5>

<p>要删除属性, 只要在访问属性的语句前面加一个 <code class="highlighter-rouge">delete</code> 即可.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="nx">object</span><span class="p">.</span><span class="nx">attibute</span><span class="p">;</span>
</code></pre></div></div>

<p>###遍历属性 (Enumerating Properties)</p>

<p>有时候你需要遍历或者枚举一个对象, 这时只要使用<code class="highlighter-rouge">for</code>循环, 在下面的例子里面, 每次循环都会把属性的名字给 key, 也就是说, 如果要进一步查看某个对象的话, 直接用括号法访问 circle 对象中的 key 属性即可.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">circle</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">circle</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-1-firsttime-for.png" alt="" /></p>

<p>如果不想让方法出现在列表中, 可以用下面的小妙招</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">circle</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">circle</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)</span>
    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">circle</span><span class="p">[</span><span class="nx">key</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有一种自带的方法, 可以将一个对象中所有的属性名称存到一个数组中返回:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">circle</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">keys</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-2-get-the-array.png" alt="" /></p>

<p>出了遍历元素, 还可以确认对象中是否存在某个属性, 这个功能非常有用:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="dl">'</span><span class="s1">radius</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">circle</span><span class="p">)</span>
  	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">circle has a radius</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-3-circle-has-a-radius.png" alt="" /></p>

<p>简而言之: 要遍历对象, 使用 for 循环; 要获取所有的属性名称, 使用 <code class="highlighter-rouge">Object.keys()</code> 方法; 要确定是否存在某个元素, s使用<code class="highlighter-rouge">if('what' in object)</code> 语句.</p>

<h2 id="抽象-abstraction">抽象 (abstraction)</h2>

<p>值暴露需要的, 隐藏内部的. Hide the details, Show the essentials</p>

<h3 id="私有属性-private-properties">私有属性 Private Properties</h3>

<p>如果你要设置私有的属性来防止被外部访问, 直接在构造函数里面用 <code class="highlighter-rouge">let</code>进行声明就好了.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">radius</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 这里的作用域是构造函数本身.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">raduis</span> <span class="o">=</span> <span class="nx">radus</span><span class="p">;</span> <span class="c1">// 这里的作用域是 new 生成的新对象.</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>前面我们提到 构造函数中的 <code class="highlighter-rouge">this</code> 指向的是<code class="highlighter-rouge">new</code>产生的空对象, 那么如果我们在声明新的变量的时候把<code class="highlighter-rouge">this</code>去掉, 就意味着新的变量作用域是构造函数本身, 而不是新建的对象, 在构造函数执行完毕之后, 这些在构造函数内部的对象就被销毁了, 不会保留到最后, 自然不能从外部被访问.</p>

<p>另外, 在作用域上还需要更加细分, 详情请见之后的文章:  “closure 和 scope – JS 作用域 48min”</p>

<h3 id="getters--setters">Getters / Setters</h3>

<p>当对象中已经有私有的属性时, 如何在对象外部获取和设定私有属性呢? Gitters 可以用来在外部读取只读属性, Setter 可以在外部修改属性.</p>

<p>当然, 如果要获取某个私有变量的值, 可以直接写一个函数返回就可以了, 就像 java 里面的取值函数一样. 但是这么做不能对值进行修改, 而且用写函数的方法来写变量真的是挺别扭的…</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="k">this</span><span class="p">.</span><span class="nx">getDefaultLocation</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">defaultLocation</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p>而 getter 和 setter 就可以完美的解决这个问题: 利用 Object 中的 defineProperty 方法进行操作.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">defaultLocation</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">defaultLocation</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">defaultLocation</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">})</span>
</code></pre></div></div>

<p>其中 defineProperty 有几个参数: 第一个参数决定作用在哪一个对象上, 第二个是用来访问 getter 和 setter 的变量名, 第三个写包含 getter 和 setter 的对象. 可以只写 getter 意味着这个值只读不能修改会报错, 也可以只写 setter 意味着只能修改不能读…</p>

<p>之后就可以在外部对这些变量进行访问了, 简单方便.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span><span class="p">);</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/heidaren0000/blogGallery/master/imgs/1-4-4-get-private-with-getter.png" alt="" /></p>

<p>这个例子的完整代码</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">Circle</span><span class="p">(</span><span class="nx">raduis</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">color</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">=</span> <span class="nx">raduis</span><span class="p">;</span>

    <span class="nx">defaultLocation</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">};</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">computeOptimumLocation</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">factory</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">draw</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">computeOptimumLocation</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">draw</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">'</span><span class="s1">defaultLocation</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">defaultLocation</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">defaultLocation</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span><span class="p">);</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">defaultLocation</span><span class="p">);</span>
</code></pre></div></div>

<p>下次写一下有关 JavaScript 中的 prototype (模板).</p>

  </div><a class="u-url" href="/javascript/2020/02/15/JSOOP.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <h2 class="footer-heading">Daren&#39;s Daliy</h2>
        <ul class="contact-list">
          <li class="p-name">黑大任</li>
          <li><a class="u-email" href="mailto:heidaren0000@gmail.com">heidaren0000@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>我们刚刚来到山脚. 前路漫漫, 可惜不是所有人都能够一览群山. We just at foot of mountain. It still a long way to go, what a pity that not everyone could up to the top.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
